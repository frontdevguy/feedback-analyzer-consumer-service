name: Deploy Lambda Function

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  AWS_REGION: us-east-1
  QUEUE_FUNCTION_NAME: unc-queue-lambda
  DYNAMO_FUNCTION_NAME: unc-dynamo-lambda
  QUEUE_NAME: unc-consumer-queue.fifo
  DYNAMODB_CHAT_TABLE: chats
  DYNAMODB_SESSION_TABLE: sessions

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install and package dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt -t ./package/
          cp queue_function.py ./package/
          cp dynamo_function.py ./package/
          cp config.py ./package/
          cp logger_setup.py ./package/
          cp -r handlers/ ./package/

      - name: Create deployment zip
        run: |
          cd package
          zip -r ../lambda-deployment.zip .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Normalize Queue Names
        id: normalize
        run: |
          RAW_QUEUE_NAME="${{ env.QUEUE_NAME }}"
          CLEAN_QUEUE_NAME="${RAW_QUEUE_NAME%.fifo}.fifo"
          DLQ_NAME="${CLEAN_QUEUE_NAME%.fifo}-dlq.fifo"

          echo "CLEAN_QUEUE_NAME=$CLEAN_QUEUE_NAME" >> $GITHUB_ENV
          echo "DLQ_NAME=$DLQ_NAME" >> $GITHUB_ENV

      - name: Create or verify IAM role and permissions
        run: |
          ROLE_NAME="consumer-lambda-execution-role"
          ACCOUNT_ID="${{ secrets.AWS_ACCOUNT_ID }}"
          REGION="${{ env.AWS_REGION }}"

          if ! aws iam get-role --role-name $ROLE_NAME > /dev/null 2>&1; then
            aws iam create-role \
              --role-name $ROLE_NAME \
              --assume-role-policy-document '{
                "Version": "2012-10-17",
                "Statement": [{
                  "Effect": "Allow",
                  "Principal": {"Service": "lambda.amazonaws.com"},
                  "Action": "sts:AssumeRole"
                }]
              }'
          fi

          BASIC_POLICY_ARN="arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
          if ! aws iam list-attached-role-policies --role-name $ROLE_NAME | grep -q "$BASIC_POLICY_ARN"; then
            aws iam attach-role-policy \
              --role-name $ROLE_NAME \
              --policy-arn $BASIC_POLICY_ARN
          fi

          echo '{
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": ["secretsmanager:GetSecretValue"],
                "Resource": "arn:aws:secretsmanager:'$REGION':'$ACCOUNT_ID':secret:*"
              },
              {
                "Effect": "Allow",
                "Action": [
                  "sqs:ReceiveMessage",
                  "sqs:DeleteMessage",
                  "sqs:GetQueueAttributes",
                  "sqs:ChangeMessageVisibility"
                ],
                "Resource": [
                  "arn:aws:sqs:'$REGION':'$ACCOUNT_ID':'$CLEAN_QUEUE_NAME'",
                  "arn:aws:sqs:'$REGION':'$ACCOUNT_ID':'$DLQ_NAME'"
                ]
              },
              {
                "Effect": "Allow",
                "Action": [
                  "dynamodb:CreateTable",
                  "dynamodb:UpdateTable",
                  "dynamodb:DescribeTable",
                  "dynamodb:PutItem",
                  "dynamodb:GetItem",
                  "dynamodb:UpdateItem",
                  "dynamodb:DeleteItem",
                  "dynamodb:Query",
                  "dynamodb:BatchWriteItem",
                  "dynamodb:GetRecords",
                  "dynamodb:GetShardIterator",
                  "dynamodb:DescribeStream",
                  "dynamodb:ListStreams"
                ],
                "Resource": [
                  "arn:aws:dynamodb:'$REGION':'$ACCOUNT_ID':table/'$DYNAMODB_CHAT_TABLE'",
                  "arn:aws:dynamodb:'$REGION':'$ACCOUNT_ID':table/'$DYNAMODB_SESSION_TABLE'",
                  "arn:aws:dynamodb:'$REGION':'$ACCOUNT_ID':table/'$DYNAMODB_CHAT_TABLE'/index/*",
                  "arn:aws:dynamodb:'$REGION':'$ACCOUNT_ID':table/'$DYNAMODB_SESSION_TABLE'/index/*",
                  "arn:aws:dynamodb:'$REGION':'$ACCOUNT_ID':table/'$DYNAMODB_CHAT_TABLE'/stream/*"
                ]
              },
              {
                "Effect": "Allow",
                "Action": [
                  "logs:CreateLogGroup",
                  "logs:CreateLogStream",
                  "logs:PutLogEvents"
                ],
                "Resource": [
                  "arn:aws:logs:'$REGION':'$ACCOUNT_ID':log-group:/aws/lambda/'${{ env.QUEUE_FUNCTION_NAME }}':*",
                  "arn:aws:logs:'$REGION':'$ACCOUNT_ID':log-group:/aws/lambda/'${{ env.DYNAMO_FUNCTION_NAME }}':*"
                ]
              }
            ]
          }' > policy.json

          aws iam put-role-policy \
            --role-name $ROLE_NAME \
            --policy-name CustomPermissions \
            --policy-document "file://policy.json"

          sleep 10

      - name: Create or verify DynamoDB Session table
        run: |
          TABLE_NAME="${{ env.DYNAMODB_SESSION_TABLE }}"

          if ! aws dynamodb describe-table --table-name $TABLE_NAME > /dev/null 2>&1; then
            echo "Creating DynamoDB Session table $TABLE_NAME..."
            aws dynamodb create-table \
              --table-name $TABLE_NAME \
              --attribute-definitions \
                AttributeName=session_id,AttributeType=S \
                AttributeName=sender_id,AttributeType=S \
                AttributeName=created_at,AttributeType=N \
                AttributeName=status,AttributeType=S \
              --key-schema \
                AttributeName=session_id,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --tags Key=Environment,Value=production \
              --global-secondary-indexes \
                "[{
                    \"IndexName\": \"SenderSessionsIndex\",
                    \"KeySchema\": [
                        {\"AttributeName\": \"sender_id\", \"KeyType\": \"HASH\"},
                        {\"AttributeName\": \"created_at\", \"KeyType\": \"RANGE\"}
                    ],
                    \"Projection\": {\"ProjectionType\": \"ALL\"}
                },
                {
                    \"IndexName\": \"StatusIndex\",
                    \"KeySchema\": [
                        {\"AttributeName\": \"status\", \"KeyType\": \"HASH\"},
                        {\"AttributeName\": \"created_at\", \"KeyType\": \"RANGE\"}
                    ],
                    \"Projection\": {\"ProjectionType\": \"ALL\"}
                }]"

            echo "Waiting for table to become active..."
            aws dynamodb wait table-exists --table-name $TABLE_NAME
          else
            echo "DynamoDB Session table $TABLE_NAME already exists"
          fi

      - name: Create or verify DynamoDB Chat table
        run: |
          TABLE_NAME="${{ env.DYNAMODB_CHAT_TABLE }}"

          if ! aws dynamodb describe-table --table-name $TABLE_NAME > /dev/null 2>&1; then
            echo "Creating DynamoDB Chat table $TABLE_NAME..."
            aws dynamodb create-table \
              --table-name $TABLE_NAME \
              --attribute-definitions \
                AttributeName=sender_id,AttributeType=S \
                AttributeName=message_id,AttributeType=S \
                AttributeName=chat_type,AttributeType=S \
                AttributeName=created_at,AttributeType=N \
                AttributeName=session_id,AttributeType=S \
              --key-schema \
                AttributeName=sender_id,KeyType=HASH \
                AttributeName=message_id,KeyType=RANGE \
              --billing-mode PAY_PER_REQUEST \
              --stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES \
              --tags Key=Environment,Value=production \
              --global-secondary-indexes \
                "[{
                    \"IndexName\": \"ChatTypeIndex\",
                    \"KeySchema\": [
                        {\"AttributeName\": \"chat_type\", \"KeyType\": \"HASH\"},
                        {\"AttributeName\": \"created_at\", \"KeyType\": \"RANGE\"}
                    ],
                    \"Projection\": {\"ProjectionType\": \"ALL\"}
                },
                {
                    \"IndexName\": \"SenderTimeIndex\",
                    \"KeySchema\": [
                        {\"AttributeName\": \"sender_id\", \"KeyType\": \"HASH\"},
                        {\"AttributeName\": \"created_at\", \"KeyType\": \"RANGE\"}
                    ],
                    \"Projection\": {\"ProjectionType\": \"ALL\"}
                },
                {
                    \"IndexName\": \"SessionIndex\",
                    \"KeySchema\": [
                        {\"AttributeName\": \"session_id\", \"KeyType\": \"HASH\"},
                        {\"AttributeName\": \"created_at\", \"KeyType\": \"RANGE\"}
                    ],
                    \"Projection\": {\"ProjectionType\": \"ALL\"}
                }]"

            echo "Waiting for table to become active..."
            aws dynamodb wait table-exists --table-name $TABLE_NAME
          else
            # Enable streams if not already enabled
            STREAM_SPEC=$(aws dynamodb describe-table --table-name $TABLE_NAME --query 'Table.StreamSpecification')
            if [ "$STREAM_SPEC" = "null" ] || [ "$(echo $STREAM_SPEC | jq -r '.StreamEnabled')" = "false" ]; then
              aws dynamodb update-table \
                --table-name $TABLE_NAME \
                --stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
            fi
          fi

          # Store the stream ARN for later use
          STREAM_ARN=$(aws dynamodb describe-table --table-name $TABLE_NAME --query 'Table.LatestStreamArn' --output text)
          echo "STREAM_ARN=$STREAM_ARN" >> $GITHUB_ENV

      - name: Create or verify SQS queues
        run: |
          DLQ_URL=$(aws sqs get-queue-url --queue-name $DLQ_NAME --output text --query 'QueueUrl' 2>/dev/null || echo "")
          if [ -z "$DLQ_URL" ]; then
            DLQ_URL=$(aws sqs create-queue \
              --queue-name "$DLQ_NAME" \
              --attributes '{"FifoQueue":"true","ContentBasedDeduplication":"true","MessageRetentionPeriod":"1209600"}' \
              --output text --query 'QueueUrl')
          fi

          DLQ_ARN=$(aws sqs get-queue-attributes \
            --queue-url "$DLQ_URL" \
            --attribute-names QueueArn \
            --output text --query 'Attributes.QueueArn')

          QUEUE_URL=$(aws sqs get-queue-url --queue-name $CLEAN_QUEUE_NAME --output text --query 'QueueUrl' 2>/dev/null || echo "")
          if [ -z "$QUEUE_URL" ]; then
            QUEUE_URL=$(aws sqs create-queue \
              --queue-name "$CLEAN_QUEUE_NAME" \
              --attributes '{
                "FifoQueue": "true",
                "ContentBasedDeduplication": "true",
                "VisibilityTimeout": "300",
                "MessageRetentionPeriod": "345600",
                "RedrivePolicy": "{\"deadLetterTargetArn\":\"'$DLQ_ARN'\",\"maxReceiveCount\":3}"
              }' \
              --output text --query 'QueueUrl')
          else
            aws sqs set-queue-attributes \
              --queue-url "$QUEUE_URL" \
              --attributes '{
                "RedrivePolicy": "{\"deadLetterTargetArn\":\"'$DLQ_ARN'\",\"maxReceiveCount\":3}"
              }'
          fi

          echo "QUEUE_URL=$QUEUE_URL" >> $GITHUB_ENV
          echo "DLQ_URL=$DLQ_URL" >> $GITHUB_ENV

      - name: Deploy or create Queue Lambda function
        run: |
          if aws lambda get-function --function-name ${{ env.QUEUE_FUNCTION_NAME }} > /dev/null 2>&1; then
            aws lambda update-function-code \
              --function-name ${{ env.QUEUE_FUNCTION_NAME }} \
              --zip-file fileb://lambda-deployment.zip
            aws lambda wait function-updated --function-name ${{ env.QUEUE_FUNCTION_NAME }}
          else
            aws lambda create-function \
              --function-name ${{ env.QUEUE_FUNCTION_NAME }} \
              --runtime python3.11 \
              --role arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/consumer-lambda-execution-role \
              --handler queue_function.queue_handler \
              --zip-file fileb://lambda-deployment.zip \
              --timeout 300 \
              --memory-size 256 \
              --description "Unc Consumer Lambda Function deployed via GitHub Actions" \
              --environment "Variables={SQS_QUEUE_URL=${{ env.QUEUE_URL }}}" \
              --tracing-config Mode=Active

            aws lambda wait function-exists --function-name ${{ env.QUEUE_FUNCTION_NAME }}
            aws lambda wait function-updated --function-name ${{ env.QUEUE_FUNCTION_NAME }}
          fi

      - name: Deploy or create DynamoDB Stream Lambda function
        run: |
          if aws lambda get-function --function-name ${{ env.DYNAMO_FUNCTION_NAME }} > /dev/null 2>&1; then
            aws lambda update-function-code \
              --function-name ${{ env.DYNAMO_FUNCTION_NAME }} \
              --zip-file fileb://lambda-deployment.zip
            aws lambda wait function-updated --function-name ${{ env.DYNAMO_FUNCTION_NAME }}
          else
            aws lambda create-function \
              --function-name ${{ env.DYNAMO_FUNCTION_NAME }} \
              --runtime python3.11 \
              --role arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/consumer-lambda-execution-role \
              --handler dynamo_function.dynamo_handler \
              --zip-file fileb://lambda-deployment.zip \
              --timeout 300 \
              --memory-size 256 \
              --description "Unc DynamoDB Stream Handler Lambda Function" \
              --tracing-config Mode=Active

            aws lambda wait function-exists --function-name ${{ env.DYNAMO_FUNCTION_NAME }}
            aws lambda wait function-updated --function-name ${{ env.DYNAMO_FUNCTION_NAME }}
          fi

      - name: Create CloudWatch Log Groups
        run: |
          # Create log groups if they don't exist
          for FUNCTION_NAME in "${{ env.QUEUE_FUNCTION_NAME }}" "${{ env.DYNAMO_FUNCTION_NAME }}"; do
            LOG_GROUP="/aws/lambda/$FUNCTION_NAME"
            if ! aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" | grep -q "$LOG_GROUP"; then
              aws logs create-log-group --log-group-name "$LOG_GROUP"
              aws logs put-retention-policy --log-group-name "$LOG_GROUP" --retention-in-days 30
            fi
          done

      - name: Update Queue Lambda configuration
        run: |
          aws lambda update-function-configuration \
            --function-name ${{ env.QUEUE_FUNCTION_NAME }} \
            --runtime python3.11 \
            --timeout 300 \
            --memory-size 256 \
            --environment "Variables={
              SQS_QUEUE_URL=${{ env.QUEUE_URL }},
              LOG_LEVEL=DEBUG
            }" \
            --tracing-config Mode=Active

          aws lambda wait function-updated --function-name ${{ env.QUEUE_FUNCTION_NAME }}

      - name: Update DynamoDB Stream Lambda configuration
        run: |
          aws lambda update-function-configuration \
            --function-name ${{ env.DYNAMO_FUNCTION_NAME }} \
            --runtime python3.11 \
            --timeout 300 \
            --memory-size 256 \
            --environment "Variables={LOG_LEVEL=DEBUG}" \
            --tracing-config Mode=Active

          aws lambda wait function-updated --function-name ${{ env.DYNAMO_FUNCTION_NAME }}

      - name: Configure Queue Lambda trigger
        run: |
          # Get Queue ARN for permissions
          QUEUE_ARN=$(aws sqs get-queue-attributes \
            --queue-url "${{ env.QUEUE_URL }}" \
            --attribute-names QueueArn \
            --output text --query 'Attributes.QueueArn')

          # Remove existing triggers (ignore if not exists)
          aws lambda remove-permission \
            --function-name ${{ env.QUEUE_FUNCTION_NAME }} \
            --statement-id sqs-trigger || true

          # Add SQS trigger permission
          aws lambda add-permission \
            --function-name ${{ env.QUEUE_FUNCTION_NAME }} \
            --statement-id sqs-trigger \
            --action lambda:InvokeFunction \
            --principal sqs.amazonaws.com \
            --source-arn "$QUEUE_ARN"

          # Create event source mapping
          MAPPING_UUID=$(aws lambda list-event-source-mappings \
            --function-name ${{ env.QUEUE_FUNCTION_NAME }} \
            --query "EventSourceMappings[?EventSourceArn=='$QUEUE_ARN'].UUID" \
            --output text)

          if [ -z "$MAPPING_UUID" ] || [ "$MAPPING_UUID" = "None" ]; then
            aws lambda create-event-source-mapping \
              --function-name ${{ env.QUEUE_FUNCTION_NAME }} \
              --event-source-arn "$QUEUE_ARN" \
              --batch-size 10 \
              --scaling-config MaximumConcurrency=2
          fi

      - name: Configure DynamoDB Stream Lambda trigger
        run: |
          # Remove existing triggers (ignore if not exists)
          aws lambda remove-permission \
            --function-name ${{ env.DYNAMO_FUNCTION_NAME }} \
            --statement-id dynamodb-trigger || true

          # Add DynamoDB trigger permission
          aws lambda add-permission \
            --function-name ${{ env.DYNAMO_FUNCTION_NAME }} \
            --statement-id dynamodb-trigger \
            --action lambda:InvokeFunction \
            --principal dynamodb.amazonaws.com \
            --source-arn "${{ env.STREAM_ARN }}"

          # Create event source mapping
          MAPPING_UUID=$(aws lambda list-event-source-mappings \
            --function-name ${{ env.DYNAMO_FUNCTION_NAME }} \
            --query "EventSourceMappings[?EventSourceArn=='${{ env.STREAM_ARN }}'].UUID" \
            --output text)

          if [ -z "$MAPPING_UUID" ] || [ "$MAPPING_UUID" = "None" ]; then
            aws lambda create-event-source-mapping \
              --function-name ${{ env.DYNAMO_FUNCTION_NAME }} \
              --event-source-arn "${{ env.STREAM_ARN }}" \
              --batch-size 100 \
              --starting-position LATEST \
              --maximum-batching-window-in-seconds 3 \
              --filter-criteria '{
                "Filters": [
                  {
                    "Pattern": "{\"eventName\":[\"INSERT\"]}"
                  }
                ]
              }'
          fi

      - name: Wait for Lambda update
        run: |
          aws lambda wait function-updated --function-name ${{ env.QUEUE_FUNCTION_NAME }}
          aws lambda wait function-updated --function-name ${{ env.DYNAMO_FUNCTION_NAME }}

      - name: Set up scheduled warmers for queue and dynamo lambdas
        run: |
          REGION=${{ env.AWS_REGION }}
          ACCOUNT_ID=${{ secrets.AWS_ACCOUNT_ID }}

          for FUNCTION_NAME in "${{ env.QUEUE_FUNCTION_NAME }}" "${{ env.DYNAMO_FUNCTION_NAME }}"; do
            RULE_NAME="warm-up-${FUNCTION_NAME}"
            SCHEDULE="rate(5 minutes)"
            STATEMENT_ID="warmup-${FUNCTION_NAME}-permission"

            echo "Creating rule $RULE_NAME for $FUNCTION_NAME..."
            aws events put-rule \
              --name "$RULE_NAME" \
              --schedule-expression "$SCHEDULE"

            echo "Adding permission for $FUNCTION_NAME if missing..."
            if ! aws lambda get-policy --function-name $FUNCTION_NAME | grep -q "$STATEMENT_ID"; then
              aws lambda add-permission \
                --function-name $FUNCTION_NAME \
                --statement-id $STATEMENT_ID \
                --action lambda:InvokeFunction \
                --principal events.amazonaws.com \
                --source-arn arn:aws:events:$REGION:$ACCOUNT_ID:rule/$RULE_NAME
            else
              echo "Permission $STATEMENT_ID already exists."
            fi

            echo "Adding $FUNCTION_NAME as target of $RULE_NAME..."
            aws events put-targets \
              --rule "$RULE_NAME" \
              --targets "Id"="1","Arn"="arn:aws:lambda:$REGION:$ACCOUNT_ID:function:$FUNCTION_NAME"
          done

      - name: Print deployment info
        run: |
          echo "Deployment Complete!"
          echo "SQS Queue URL: ${{ env.QUEUE_URL }}"
